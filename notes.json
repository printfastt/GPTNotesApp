{"Untitled Note": "Compressed files\n\t- Often larger files are compressed to save disk space. If this is the case then the user must make the file revert to it's original format in order to be able to do anything with it. A popular compressing command is called, simply, compress.\n\t- The command:\n\t- $compress filename (will compress the file)\n\t- $uncompress filename (will uncompress the file)\n\nProcessing text files:\n\t- Sort - sort into alphabetical order\n\t- Uniq - remove duplicate lines \n\t- Grep - fine lines containing given string or pattern\n\t- Wc - will count the words in a document\n\t- Head - will output certain lines oa file.\n\t- Cat - concatenates file vertically (appends files to one another)\n\n\nSort\nSort - sort into alphabetical order\nSort -n sort into numerical order\nSort -m merge sorted fiels into one sorted file\nSort -r sort into reverse order (highest first)\nSort -c check a file is already sorted.", "Unix OS": "Unix operating system\n\t- Operating system: way for the computer to manage operation between users and the hardware of the computer.\n\t- OS based off of UNIX\n\t\t\u25cb Solaris(server and workstation)\n\t\t\u25cb Darwin(iOS, WatchOS, tvOS, ipadOS)\n\nHistory of UNIX\n\t- Began in multiplexed operating and computing system(MULTICS) started in 1960.\n\t- UNICS first version in 1969.\n\t- 1973 Dennis Richie writes the C compiler for UNIX fifth version.\n\t- 1978 Seventh edition two branches SVR4 and BSD (Berkeley version) developed at ub.\n\t- Linux developed as a unix look alike.\n\nUNIX family tree\n\n \nUNIX ties to C language\n\t- Most computer languages were being written in assembly language\n\t- C language was high enough to be written for various hardware's\n\t- C functions could be applied to the Unix operating systems\n\t- Understanding C can make understanding unix a lot easier.\n\nUNIX benefits\n\t- Great for networking capabilities and works very well with the web.\n\t- Written in a machine independent language and is flexible on different types of hardware\n\t- Flexibility and adaptable.\n\nArchitecture\n\t- Kernel\n\t- Shell\n\t- User commands and apps.\n\n\n\n\nHardware: represents the physical components of a computer system, including the CPU, memory, hard drives, and other peripherals. The hardware is responsible for executing machine-level instructions and performing low-level tasks.\n\nKernel: the kernel is the core part of the operating system that intereacts directly with the hardware. It manages system resources, including memory, processes, and device input/output (IO). The kernel acts as a bridge between the hardware and the software, ensuring that applications can run efficiently and securely. \n\nShell: the shell is a command-line interfact (CLI) that allows users to interact with the kernal and the operating system. It interprets and executed commands enetered by the user. The shell acts as an intermediary between the user and the kernel, providing an interface to access the underlying system functionalities.\n\t- Bash (bourne again shell): a widely used shell that is the default on many unix-like systems\n\t- Csh( C shell) known for its c-like syntax and scripting capabilities\n\t- Ksh (korn shell): combines features of both the bourne shell and the. C shell, offering enhanced scripting capabilities\n\t- Tcsh: an enhanced version of the C shell with additional featuresl ike command-line completion\n\nCommand line: the commandl ine is the interface where users can type commands to interact with the operating system. It provides direct access to the shell, allowing users to execute commands, run scripts, and perform system operations.\n\n\nUser applications: this layer represents the various user-level applications and utilities that users interact with regularly.\nUNIX FILE SYSTEM.\nDenoted by '/'. All files and directories are contained within this directory, and it is denoted by a single forward slash.\n\nUsr is usually where most of the systems application binaries, libraries, and documentation are stored. \n\n\n\n\n\n\nhttps://mally.stanford.edu/~sr/computing/basic-unix.html", "Operating Systems": "Intro to OS\n\t- Windows\n\t- Linux distros\n\t\t\u25cb Ubuntu\n\t\t\u25cb Kali\n\t\t\u25cb Etc\n\t- Mac os x \n\t- Android\n\nAn operating system(os) is a program that manages the computer hardware\nIt also provides a basis for application programs and acts as a intermediary between the computer and its user\n\t- CPU\n\t- Memory\n\t- I/O devices\n\t- Ram \n\t- NIC - network interface card\n\n\nDevices for the computer\n\t- Devices are things like your mouse and keyboard\n\t- The devices are used to create input from the user to the computer\n\t- Based on the input the computer receives the computer will then generate output\n\t- This is what is referred to as input/output devices or I/O\n\nApplication software:\n\t- A program that can be directly used by the user to interact with the computer. The applications will use input devices that will be read from the user. After the input is received the computers operating system will process the input and based on the application it is being used for it will determine the output that is generated:\n\t- Ex:\n\t\t\u25cb Word processors\n\t\t\u25cb Spreadsheets\n\t\t\u25cb Compilers\n\t\t\u25cb Web browsers\n\nMemory allocation\n\t- When a user uses a application, the actions form the user is taken by the OS and will manage it by storing it into memory. The os will determine the amount of space needed to store the data and will send the data to the hard drive to be stored. When the user needs the data the OS will retrieve the data and display it for the user.\n\n\nTypes of OS\n\t- Batch OS\n\t- Time sharing OS\n\t- Distrubed OS\n\t- Network OS\n\t- Real time OS\n\t- Multi programming / processing / tasking OS\n\nBatch OS\nA batch processing operating system (batchOS) is an open-source operating system desgined to manage multiple jobs in sequence. It is based on the CentsOS linux distribution and is licensed under the GNU general public license. \n\n\n\n\nMemory allocation\n\t- When a user uses an application, the actions from the user is taken by the OS and will manage it by storing it into memory. The OS will determine the amount of space needed to store the data and will send the data to the hard drive to be stored. When the user needs the data the OS will retrieve the data and display it for the user.\n\t- The operating system will manage all the memory and process all the information for the computer.\n\nTypes of OS\n\t- Batch OS\n\t- Time sharing OS\n\t- Distributed OS\n\t- Network OS\n\t- Real time OS\n\t- Multi programming / processing / tasking OS\n\n\n\n\nUnix is a machine independent OS\n\t- Unix is a machine independent OS. Not specific to just one type of computer hardware. Desgined from the beginning to be indepndent of the computer hardware. UNIX is a software development environment\n\t- UNIX is a multi-user, multi-tasking operating system.\n\nHardware indepdence\n\t- Operating system code is written in c language rather than a specific assembly language\n\t- Operating system software can be easily moved from one hardware system to another\n\t- UNIX applications can be easily moved to other UNIX machines. Porting is usually as simple as transfer of the source and a recompile.\nProductive environment for software development\n\t- Rich set of tools\n\t- Versatile command language\nDistributed processing and multi-tasking\n\n\nGoals of all OS\n\t- Convenience\n\t- Efficiency\n\t- Both\n\nFunction of OS\n\t- Interface between user and hardware\n\t- Allocation of resources\n\t- Management of memory, security, ETC.", "UNIX OS Structure": "- Root\n\t\t\u25cb The directories below the root are designated by the pathnames:\n\t\t\t\u00a7 /bin\n\t\t\t\u00a7 /etc\n\t\t\t\u00a7 /usr\n\t\t\u25cb Users have their own directory in which they can create and delete files, and create their own sub-directories. \n\t\t\u25cb For example: /user/ei/eib035\n\nSome typical system directories below the root directory:\n\t\t\u25cb /bin contains many of the programs which will be executed by the users\n\t\t\u25cb /etc files used by system admins\n\t\t\u25cb /dev hardware peripheral devices\n\t\t\u25cb /lib system libraries\n\t\t\u25cb /usr normally contains applications software\n\t\t\u25cb /home home directors for different systems\n\n\nHome directory\n\t- Each user has a home directory. They will be attached to this directory when they log in. jenny brown's home directory is:\n\t/home/sunserv1_b/lnp5jb\n\t\n\t- The symbol ~ can be used to refer to the home directory. You can refer to your home directory like:\n\t\t\u25cb ~/bin/hello\n\t- Rather than typing the long form:\n\t\t\u25cb /home/sunserv1_b/lnp5jb/bin/hello\n\nParent directory\n\t- The parent directory is the directory above the curren directory.\n\t- The parent directory can be referred to by the ..characters (two full stops)\nEx: cd ../webDev\nWill take you back one directory then into webdev.\n\n\nLinking files\n\t- The ln command can be used to link files and directories across the filestore system.\n\nMore Shell Command\n\t- Unix commands have the general format:\n\t\t\u25cb Command [options] [item]\n\t- Items in brackets are optional, and words in italics are generic identifiers\n\t- Shell commands are case sensitive\n\t\t\u25cb LS is not a command but ls is a command\n\t- The command item is given last. This is very often a file name.\n\t- Echo commands will print what you write for the echo\n\nShell commands\n\t- Who/finger\n\t\t\u25cb Will list user that are logged in\n\t- Deleting files\n\t\t\u25cb Rm test.f\n\t- Displaying files\n\t\t\u25cb The command cat is used to display the contents of a file on the screen.\n\t\t\t\u00a7 Cat file1\n\t- Creating files\n\t\t\u25cb When typing in a new file\n\t\t\u25cb The input must be terminatd by\n\t\t\u25cb ^d\nCat>test.f\n\t- Copying files\n\t\t\u25cb Cp old_file new_file\n\t- Renaming files\n\t\t\u25cb Mv file2 temp\n\t- Overwriting files\n\t\t\u25cb Mv file2 temp\n\t\t\u25cb Rm file\n\t- The * is used to fund all names of file the same to remove the same name rm *file", "File Permissions": "What are file permissions?\n\t- Unix file system securiy can prevent unauthorized users from reading or altering files.\n\t- Every file and directory has specific permissions associated with it, giving different categories of user certain permissions to look at or change a file, and to run executable files.\n\u2022 \n\n\nDisplay file permissions\n- Ls -l [filename]\n\n- \n\n\n\n\nChange file permissions\n- The command chmod is used to change the permissions on a file. The format of this command is:\n\t- Chmod mode filename\n\nFor example, to add read permission for the group to the file file1, give the command:\n- Chmod g+r file1\n\n\nChmod modes\n- In the command:\n- % chmod mode filename\n\n- The mode consists of three elements:\n- Who\n- Operator\n- Permissions\n- The following options are possible\n\t- Who\n\t\t\u25cb U user (owner)\n\t\t\u25cb G group\n\t\t\u25cb O other\n\t\t\u25cb A all\n\nOperators and permissions\n\t- -remove permission\n\t- + add permission\n\t- = assign permission\n\t- R read\n\t- W write\n\t- X execute", "Standard I/O": "Standard input\n\n\t- Input to unix commands is normally given from the keyboard. For example you can use the cat command interactively:\n% cat\nHello\n\t- You typeHello\n\t- Response^D\n\t- You type%\n\nStandard output\n\t- Outputs can be displayed on the monitor of given to a file.\n\t- Outputs can be assigned and redirected. \n\t- Simple commands like echo will give a direct print to screen of whatever you type.\n\t- Some outputs are after a filter is ran and the output is given.\n\nRe-direction of standard input\n\t- It is possible to redirect standard input so that the input is taken from a file.\n\t- A text can be put into the file report, which can be fedi nto the spell command.\n$cat > report\nInput to the spell utility\nCan come from a file\n^D\n$spell < report\nUtility\n\n\n\n\n\n\n\n\n\n\n\nIf you have a report containing many spelling mistakes you may wish to keep a list of the mistakes in a file.\nSpell < report > errors", "File Processing": "Compressed files\n\t- Often larger files are compressed to save disk space. If this is the case then the user must make the file revert to it's original format in order to be able to do anything with it. A popular compressing command is called, simply, compress.\n\t- The command:\n\t- $compress filename (will compress the file)\n\t- $uncompress filename (will uncompress the file)\n\nProcessing text files:\n\t- Sort - sort into alphabetical order\n\t- Uniq - remove duplicate lines \n\t- Grep - fine lines containing given string or pattern\n\t- Wc - will count the words in a document\n\t- Head - will output certain lines oa file.\n\t- Cat - concatenates file vertically (appends files to one another)\n\n\nSort\nSort - sort into alphabetical order\nSort -n sort into numerical order\nSort -m merge sorted fiels into one sorted file\nSort -r sort into reverse order (highest first)\nSort -c check a file is already sorted.", "Regex": "When UNIX is started, the directory hierarchy (starting with /) corresponds to the fily system located on a single disk called the root device.\n\nMounting allows root to splice the root directory of a file system into the existing directory hierarchy\n\n. File systems created on other devices can be attached to the original directory hierarchy using the mount mechanism\n\nCommands mount and unmount manage\n\nRelated with the /etc/fstab file.", "Pipes and Filters": "Sed (stream editor)\nSed [options] 'command' file\nExample: sed 's/foo/bar/'file.txt\nExplanation: rplace the first occurrence of \"foo\" with \"bar\" in each line.\n\n\nWhat are regular expressions?\nA regular expression (RE) is a string of characters that can be used to match a set of character strings. For example, to globally search for all occurences of the word \"and\" would require a search for \"and\", \"And\", \"AnD\", \"AND\", etc.\nWithout regex finding all possible occurences of \"and\" would require eight separate earches. Using an RE the search could be done with one command.\n\nRegex components:\n\t- Metacharacters\n\t- Quantifiers\n\t- Anchors\n\t- Character classes\n\t- Predefined character classes\n\t- Lookahead and lookbehind assertations\n\t- Non-capturing groups\n\t- Greedy vs non-greedy matching\n\t- Escape sequences.\n\t- POSIX character classes (used in 'grep' and 'sed')\n\n\n\nRegex quantifiers\n\n\nRegular expressions anchors\nAnchors do not match characters but positions within the text:\n\n\nRegular expressions character classes:\nCharacter classes allow matching specific sets of characters:", "Regular Exp": "\">\" tells shell to redirect the outputs to a file instead of printing the output to the screen.\n\nStdin, is also known as standard input. It is an input stream where data is sent to and read by a program. It is a file descriptor in Unix-like operating systems.\nStdout, also known as standard output, is the default file descriptor where a process can write output. In unix-like operating systems defined by POSIX standard\n\n\nFilters are programs that take plain text or standard input as standard input, transforms it into a meaningful format, and then returns it as stand\nard output. Linux has several filters.\n\n\n\n\n\nFildes (file descriptors, or fd)\n\n\n\n\n\t- A unix pipe provides a one-way flow of data.\n\t- For example, if a unix users issues the command\n\t\t\u25cb Who|sort|lpr\n\t- Then the unix shell would create three processes with two pipes between them\n\n\n\nPipe system call\n\t- A pipe can be explicitly created in Unix using the pipe system call. Two file desriptors are returned--fildes[0] and fildes[1], and they \n\t-", "OS Memory Management": "\"sed\" is a powerful command-line utility for text manipulation. \n\t- Allows search, replace, insert, and delete text in a file or input stream.\n\t- Particularly useful for batch editing operations on large files.\n$sed [options] 'command' file\nExample: sed 's/foo/bar/' file.txt\n\nA regular expression is a string of characters that can be used to match a set of character strings. \nFor ex: to globally search for all occurences of the word \"and\" would require a se\n\n\n\nwc *.txt | sort | head -2", "BASH": "Memory management\n\t- Critical without which the performance of the system is  not achieved.\n\nThere are two aspects on which the performance depends:\n\t- The amount of memory available\n\t- Optimal utilization of memory while processing of jobs.\n\nThere are four memory allocation schemes available for unix?\n\t- Single use contiguous scheme\n\t- Fixed partitions\n\t- Dynamic partitions\n\t- Relocatable dynamic partitions.\n\nSingle-user contiguous scheme\n\t- The entire program or job is first loaded into memory contiguously as much as possible before the execution.\n\t- If program size > memory size, execution will not begin.\n\t- Must increase memory or decrease program size to execute.\nAdv:\n\t- Jobs allocated sequentially. Requirment of OS' work is less.\n\t- OS just needs to check if incoming job will fit.\n\nDis:\n\t- Only one job or program is loaded into memory at one point\n\t- Memory sharing is not possible among jobs\n\t- Even tho there is space to accommodate the waiting jobs, it is not possible to accommodate more than one job.\n\t- Does not support multi-programming\n\t- Not cost-effective, serves the purpose of only one person at a time.\n\n\nFixed partition (static partition) scheme\n\t- Supports multiprogramming with in the available memory space\n\t- Main memory is divided into blocks of memory known as partitions. Each job is allocated a partition.\n\t- Each partition is of fixed size. If any job exceed partiton size then the program can't be excuted. \n\t- This scheme need to perform more steps when ocmpared to single user scheme, because the size of the job needs to be less than or equal to the size of the available partitions to ensure the job completely fits in to partition.\n\t- \n\n\nAdv:\n\t- Support for multi-programming\n\t- Jobs in other partitions are prevented from overriding the boundraries of other jobs. The partition intrusion does not exist in Single User Partiton scheme as there is only one job present and executing at any point of time.\n\t- Each partition is protected in main memory by partition intrusion.\nDis:\n\t- As the partitions are static, the systems need to be shutdown to re-configure the sizes of partitions.\n\t- If the job size is greater than the size of the memory partition then the execution of the job is not performed.\n\t- As in single user scheme, the remaining space in each partition is unused. Hence internal fragmentation occurs in this scheme.\n\nDynamic partition Scheme:\n\t- Main memory is allocated contiguously to the incoming job.\n\t- Unlike the previous schemes, memory block allocated as per the requirement of the job while loading if for processing.\n\t- Memory is efficiently allocated for the first set of incoming jobs.\n\t- After the execution is completely, the new jobs are allocated the memory in the available partition on priorty basis.\n\t- The successive of memory creates empty space between the partitions, which creates a new problem known as external fragmentation.\n\t- \n\t\nAdv:\n\t- Efficiently allocates the memory blocks to the incoming jobs\n\t- Unlike in Fixed partition, the memory is no longer wasted inside each partition.\nDis:\n\t- Avoids internal fragmentation but the subsequent allocation of available memory partitions creates an empty space between the partitions, which resulted in external fragmentation. Hence the memory gets wasted. \n\n\n\n\n\n\nRelocatable dynamic partition scheme:\n\t- All the memory allocation schemes somehow create fragmentation and this needs to be removed, as the jobsi increases, there is a demand to even use the memory blocks which are left unused.\n\t- The only situation to overcome the problems is to create relocatable dynamic partitions. This memory scheme collects all the empty blocks and combines it to make a contiguous block of memory large enough to accommodate the jobs waiting for their turn.\n\n\nAdv:\n\t- The unused memory blocks can be gathered to make one contiguous memory block, so that it can be utilized for the waiting jobs.\n\t- Allows optimal utilization of the memory and processing time.\nDis:\n\t- This scheme involves compaction and it is an overhead process, as all the activities and processing of jobs needs to be suspended until the memory compaction process gets completed.\n\t- All the currently running programs need to be relocated to make the memory locations contiguos all the addresses and address references by all the programs to be adjusted to the new memory locations.\n\n\n\nModern microprocessors intended for general-purpose use, a memory management unit, or MMU, is built into the hardware. The MMU's job is to translate virtual addresses into phyiscal adresses.\n\n\n\n\n\n\n\nDemand Paging\n\t- The process of loading the page into memory on demand (whenever page fault occurs) is known as demand paging. The process includes the following steps.\n\n\t1. If the CPU tries to refer to a page that is currently not available in the main memory, it generates an interrupt indicating a memory access fault.\n\t2. The OS puts the interrupted process in a blocking state. For the execution to proceed the OS must bring the required page into the memory.\n\t3. The OS will search for the required page in the logical address space.\n\t4. The required page will be brought from logical address space to physical address space. The page replacement algorithms are used for the decision-making of replacng the page in physical address space.\n\t5. The page table will be updated accordingly.\n\t6. The signal will be sent to the CPU to continue the program execution and it will place the proces back into the ready state.\n\n\n\n\n\n\nVirtual memory: advantages:\n\t- More processes may be maintained in the main memory: because we are going to load only some of the pages of any particular process, there is room for more processes. This leads to more efficient utilization of the processor because it is more likely that at least one of the more numerous processes will be in the ready state at any particular time.\n\t- A process may be large than all of the main memory: one of the must fundamental restrictions in programming is lifted. A process larger than the main memory can be executed because of demand paging. The OS itself loads pages of a process in the main memory as required.\n\t- It allows greater multiprogramming levels by using less of the available (primary) memory for each process.\n\nDis:\n\t- Number of tables and the amount of processor overhead for handing page interrupts are greater than in the case of simple paged management techniques.\n\n\n\n\n\n\n\nSwapping:\n\n\n\nReference string:\nThe string of memory references is called reference string. Reference strings are generated artifically or by tracing a given system and recording the address of each memory reference. The latter choice produces a large number of data, where we not two things.\n\n\t- For a given page size, we need to consider only the page number, not the entire address.\n\t- If we have a reference to page p, then any immediately following references to page p will never cause a page fault. Page p will be in memory after the first reference; the immediately following references will not fault.\n\t- For example, consider the following sequence of addresses - 123,215,600,1234,76,96\n\t- If the page size is 100, then the reference string is 1,2,6,12,0,0\n\n\n\nSegmentation in operating system:\n\t- A process is divided into segments. The chunks that a program is divided into which are not necessarily all of the same sizes are called segments. Segmentation gives user's view of the process which paging does not give. Here the user's view is mapped to physical memory.\n\t- There are two types of segmentation:\n\t\t\u25cb Virtual memory segmentation: Each process is divided into a number of segments, not all of which are resident at any one point in time.\n\t\t\u25cb Simple segmentation: each process is divided into a number of segments, all of which are loaded into memory at run time, though not necessarily contiguously.\n\nThere is no simple relationship between logical addresses and physical addresses in segmentation. A table stores the information about all such segments and is called segment table.\n\nSegment table - it maps two-dimensional logical address into one-dimensional physical address. It's each table entry has:\n\t- Base address: it contains the starting physical address where the segments reside in memory.\n\t- Limit: it specifies the length of the segment.\n\nTranslation of two-dimensional logical address to one dimensional physical address.\n\t\n\t\n\t\n\tSegment number (s): number of bits required to represent the segment.\n\tSegment offset(d): number of bits requred to represent the size of the segment.\n\t\nAdvantages of segmentation: \n\t- No internal fragmentation\n\t- Segment table consumes less space in comparison to page table in paging.\nDisadvantages of segmentation:\n\t- As processes are loaded and removed from the memory, the free memory space is broken into little pieces, causing external fragmentation.", "Mount_unmount": "When UNIX is started, the directory hierarchy (starting with /) corresponds to the fily system located on a single disk called the root device.\n\nMounting allows root to splice the root directory of a file system into the existing directory hierarchy\n\n. File systems created on other devices can be attached to the original directory hierarchy using the mount mechanism\n\nCommands mount and unmount manage\n\nRelated with the /etc/fstab file.", "Process Scheduling": "When UNIX is started, the directory hierarchy (starting with /) corresponds to the fily system located on a single disk called the root device.\n\nMounting allows root to splice the root directory of a file system into the existing directory hierarchy\n\n. File systems created on other devices can be attached to the original directory hierarchy using the mount mechanism\n\nCommands mount and unmount manage\n\nRelated with the /etc/fstab file.", "More Shell Commands": "If there are several runnable jobs, the operating system has to decide which job to run next, a process known as Process Scheduling.\n\nIn the old days, when computers ran\nbatch jobs, this was not an issue. The\ncomputer operator simply submitted the\njobs in the order that they were\ndelivered to him or her, and each job ran\nto completion. We can call this\nalgorithm First come first served, or FIFO\n(first in first out).\nHowever, even this primitive system had\nproblems. Suppose there are five jobs\nwaiting to be run. Four of the five jobs\nwill take about ten seconds each to run,\nand one will take ten minutes, but the\nten minute job was submitted first. In a\nFIFO system, the four fast jobs will all be\nheld up for a long time by a large job\nthat happened to be delivered first.\n\nIn a batch system, this was not serious since jobs were never interactive. However, if we knew ahead of time how long each job would take, we could maximize throughput. In fact, some computer centers in the '60s could actually d othis.\nWhen a user submitted a job, he or she was also asked to specify an estimated run time.\nThe operatour would then allow a job to run only for that amount of time. This was important, because, even then, programmers could write programs with infinte loops. If a program exceeded its estimated run time, the operator killed it.\n\n\nShortest job first:\n\t- Search all available jobs, find job w/ shortest run time.\n\nAsking users to estimate the urn time of their jobs put them in somewhat of a bind, because often they did not have an exact guess. If they submitted a high guess, their job would almost certainly run to completion, but it might be delayed by the operator. On the other hand, if they submitted a somewhat lower time estimate, the operator would start running it sooner, but there was a greater chance that it would time out before completing.\n\n\nKernel Schedular: \n\t- The Unix kernel controls the way that tasks (or processes) are managed on the system. The task scheduler, sometimes called process scheduler, is part of the kernel that decided which task to run next. It is responsible for best using system resources to guarantee that multiple tasks are being executed simultaneously. This makes it a core component of any multitasking operating system.\n\nTheory behind process scheduling:\n\t- If there are runnable processes in a system, atl one process must always be running. If there are more runnable processes than processor in a system, not all the processes can be running all the time\n\t- Therefore, some processes need to be stopped temporarily, or suspended, so that others can be running again. The scheduler decides what process in the queue will run next.\n\t- Unix and all other unix variants, are multitasking operating systems. That means that several tasks can be running at the same time. Unix provides a so called preemptive multitasking, where the scheduler decided when a process is suspended.\n\nPreemptive multitasking:\n\t- This is when the operating system can pause on running process to give CPU time to another process. The operating system determines when to switch between tasks, making sure that higher-priority tasks can be processed in a timely manner.\n\nPreemptive scheduling:\n\t- Essentially all modern operating systems use a preemptive scheduling strategy, so we can discuss several such algorithms.\n\nTimeslice:\n\t- The time period for which a process will be running before it is preempted is defined in advance.\n\t- It is called a timeslice of a process and represents the amount of processor time that is provided to each process.\n\t- By assigning timeslices, the scheduler makes global decisions for the running system, and prevents individual processes from dominating over the processor resources.\n\nPriority:\n\t- The scheduler evaluates processes based on their priority. To calculate the current priority of a process, the task scheduler uses complex algorithms. As a result, each process is given a value according to which it is \"allowed\" to run on a processor.\n\n\n\n\nCONT.\n\nCONT.\n\n\n\n\n\nContext switching:\n\t- The process of switching from one job to another is called a context switch. At a minimum, all that is involved is saving the register values of the process which is being preempted, copying the register values of the new process which is being run, and changing the program counter(the register in the CPU which contains the next instruction to be run).\n\nDifferent types of jobs:\n\t- \n\t- \nAny running process consists of alternating periods of computation followed by an I/O operation:\n\n\n\nQuestion: which type of jobs should be given priority, a compute intensive job, or an I/O intensive job?\nAnswer: the I/O intensive job, because it will run for a very brief period of time before issuing its next I/O command, which will put it to sleep, and then the compute intensive job can begin.\n\n\nIt is important to keep in mind throughout all of this discussion that the scheduler does not know how long a process will run or whether or not it will be I/O intensive or CPU intensive.\n\nAlso, the scheduler does not usually know whether or not a particular job is interactive or not. The only information that it has is the priority and its past history.\n\nIf we look at the kinds of jobs that are actually run on computers doing real work, it turns out that we can make some assumptions.\n\n\nScheduling algorithms:\nEarlier we said that the best algorithm for a non-preemtptive batch system was a shortest job first algorithm. When we try to generalize this to a preemptive system, we conclude that the algorithm which maximizes throughput is to always run the job which hasthe least time remaining. In practice this is impossible to implement because the scheduler has no way of knowing how long a particular job has to run. But we can get some clues from the above two observations.\n\n\n\n\n\n\n\n\n\n\n\nMultiples queues based on priority:\n\t- Have several queues depending on priority. High priority jobs are placed on one queue, low priority jobs on another. High priority jobs are run first.\n\t- This algorithm has the risk that low priority jobs might starve if there are enough high priority jobs, so one solution to this is that jobs are ready to run but have not received any CPU time recently are moved up in priority.\n\n\n\n\n\n\n\n\n\n\n\nCalculating CPU usage with decay:\n\t- A multiple queue systems assigns jobs a priority based on CPU usage. One simple but poor solution is to just assign priority based on total CPU usage so far. This effectively starves long running jobs. A second solution is to base priority only on CPU usage during the recent past, the past second for example. Thus, a job which received no CPU time in the past second is treated the same as a brand new job. An even better solution is to use an algorithm which is a hybrid between these two such that recent CPU time reduces priority more than CPU time in the distant past.\n\t- \n\t\n\nCalculating CPU usage with decay advantages:\n\t- Newly arrived jobs are given the highest priority because they have no prior CPU time.\n\t- IO intensive jobs are given priority, because, since they spend most of their time sleeping, they do not accumulate much CPU time.\n\t- Long running, CPU intensive jobs do not starve, because the longer they wait for cpu time, the lower their value of T is.\n\n\nIt would seem that it would require a lot of overhead to compute such a function, but in fact that is not the case. The following function performs this computation.\nT>n = P * time (1 - P) * T>n-1\n\nIn this formula Time is the amount of CPU time that the process used since T was last recomputed, and P is a value between zero and one. If P has the value of .5, this exactly computes the expansion above. A higher value of P gives more weight to the recent past. In other words, the function decays more quickly.", "UOS": "The role of the shell:\nA unix shell is used to:\n\t- Evaluate the command line. For ex:\n\t\t\u25cb % car nofile\n\t\t\u25cb Car: command not found\nHere the shell looks for a command called car. Since it cannot find this command it gives an error message.\nPerform variable substitution.\n\n\nFor example:\n% echo \"In directory $HOME\"\nIn directory/home/sunserv1_b/lnp5jb\n\nHere the shell variable $HOME is evaluated and displayed.\nHandle pipelines. For ex:\n% who | wc -l\n\nHere the output from who is piped through to the wc command which \n\n\nTypes of shells:\n\t- A number of shells are avaiable for Unix systems including:\n\t- Bourne shell\n\t- C shell\n\t- Korn shell\n\t- Graphical user interface (GUI) shells\n\nThe Bourne\n\t- Which was developd by Steve Bourne at Bell Laboratores, is one of the oldest shells, and, as such, has gained a lot of popularity. It is widely used for shell programming because of its efficiency and because it is available on all Unix systems. \nThe C shell\n\t- The C shell provides sophisticated interactive capabilities lacking in the Bourne shell. The C shell, which was developed at the university of California, Berkely, has a syntax which resembles the C language. Features of the C shell include a command history buffer,  command aliases and file name completion. \n\t- However the C shell does not allow efficient shell programs (also known as scripts) to be written. Due to the fact that C shell programs are written in a stlye similar to the C programming language, people who are unfamiliar with C may find the C shell difficult to program in.\nThe Korn Shell\n\t- The Korn shell combines the best features of the Bourne and C shells. Korn scripts are 95% upwardly compatible with Bourne scripts. The korn shell interactive features include:\n\t\t\u25cb In-line editiing\n\t\t\u25cb Command editing\n\t\t\u25cb Job control\nGraphical User interface (GUI) shells\nGraphical user interface (GUI) shells provide a iconic interface to Unix. GUI shells require the use of workstations (or powerful microcomputers) which perform part of the processing locally. \n\nC shell features: the history mechanism.\nThe history mechanism enables previous typed Unix commands to be re-invoked and edits. There are two forms. One is the quick substitution, which acts only on the immediately preceding command,e.g.\n\n\nC shell features: the history mechanism\n\n\n\nC Shell features: the history mechanism\n\t- It is possible to add extra options to commands re-executed. For example, to redirect output from the who command to a file called list we could give the command (for the above list):\n\t\n\nFeatures of bash\nAlthough the Bourne shell is still known as the \"standard\" shell, bash is becoming increasingly popular. In addition to Bourne shell compatibility, it includes the best features of the C and Korn.\n\n\nFeatures of bash\nBash's command-line editing modes are the features that tend to attract people to it first. With command-line editingm it's much easier to go back and fix mistakes or modify previous commands than it is with the C shell's history mechanism.\nThe rest of bash's important advantages are meant mainly for shell customizers and programmers. It has many new options and variables for customization, and its programming features have been significantly expanded to include function definition, more control structures, integer arithmetic, advanced I/O control, and more.\n\n\nGetting bash\n\n\n\n\n\nCommands, arguments, and options\nShell command lines consist of one or more words, which ae separated on a command line by blanks or TABs. The first word on the line Is the command. The rest (if any) are arguments (also called parameters) to the command, which are names of things on which the command will act.\n\n\nFor example, the command line lp myfile consists of the command lp(print a file) and the single argument myfile.\n\n\n\n\nFiles\n\nRegular files:\n\t- Also called text files; these. Contain readable characters. For example, this book was created from several regular files that contain the text of the book plus human-readable formatting instructions to the troff word processor. \nExecutable files:\n\t- Also called programs; these are invoked as commands. Some can't be read by humans; others - the shell scripts that we'll examine in this book - are just special text files. The shell itself is a non (non-human-readable) executable file called bash.\nDirectories:\n\t- These are like folders that contain other files - possibly other directories (called subdirectories). \n\n\n\n\n\n\nThe ? Wildcard matches any single character, so that if your directory contains the files program.c, program.log, and program.o, then the expression program.? Matches program.c and program.o but not program.log. The asterisk (*) is more powerful and far more widely used; it matches any string of characters. Text editor users can use the expression *.txt to match their input files. [8] table 1-3 should help demonstrate how the asterisk works. Assume that you have the files bob, darlene, dave, ed, frank, and fred in your working directory.\n\n\n\n\n\nBrace expansion:\nA concept closely related to pathname expansion is brace expansion. Whereas pathname expansion wildcards will expand to files and directors that exist, brace expansion expands to an arbitray string of a given form: an optional preamble, followed by comma-separated strings between braces, and followed by an optional postscript. If you type echo b{ed,olt,ar}s, you'll see the words beds, bolts, and bars printed. Each instance of a string inside the braces is combined with the preamble b and the postscripts.\nEcho b{ed,olt,ar}s", "20241019": "Response:\nHello! How can I assist you today?\nResponse:\nA Memory Management Unit (MMU) is a hardware component that handles all memory and caching operations associated with the processor. In particular, it is responsible for translating virtual addresses into physical addresses. It also manages memory by allocating and deallocating memory spaces as needed by programs and applications.\nResponse:\nThe memory management unit (MMU) in a computer is responsible for handling tasks related to memory. This includes translating virtual addresses into physical addresses, managing the page table for the locations of the pages, and managing code segments on the segmentation table. It also allocates and deallocates memory as necessary, ensuring the right amount of memory is allocated for each task. By doing so, the MMU helps optimize the use of the computer's memory resources.", "test": "wc *.txt | sort | head -2", "test2": ""}